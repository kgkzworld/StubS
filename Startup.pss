<File version="3.2">
  <Code><![CDATA[# Warning: Do not rename Start-MyService, Invoke-MyService and Stop-MyService functions


function Start-MyService
{
	#region Initialize global variables
    	$global:bRunService = $true
    	$global:bServiceRunning = $false
    	$global:bServicePaused = $false
    #endregion Initialize global variables
    
    #region Grab File Information
        $global:CurFileInfo = Get-Process -Id $pid | Select-Object -ExpandProperty Path
        $global:Service = @{}
        $global:Service.ServicePath = $global:CurFileInfo | Split-Path -Parent
        $global:Service.ServiceConfigFile = $($global:CurFileInfo | Split-Path -Leaf) -replace '\.exe$','.json'
        $global:Service.ServiceDebug = $false
        
        If (Test-Path -Path $('{0}\{1}' -f $global:Service.ServicePath, $($global:CurFileInfo | Split-Path -Leaf) -replace '\.exe$','.debug')) {
            $global:Service.ServiceDebug = $true
            $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Force
        }
    #endregion Grab File Information
    
    #region Query Json Config
        Try {
            $global:Service.Config = Get-Content -Path $('{0}\{1}' -f $global:Service.ServicePath, $global:Service.ServiceConfigFile) -ErrorAction Stop
        } Catch {
            Write-Host $_.Exception.Message
            If ($global:Service.ServiceDebug) {
                $_.Exception.Message | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
                $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
            }
        }
    #endregion Query Json Config
        
    #region Update Execution Policy
        $global:CurPolicy = $(Get-ExecutionPolicy | Out-String).Trim()
        Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser
    #endregion Update Execution Policy
}

function Invoke-MyService
{
	$global:bServiceRunning = $true
	While ($global:bRunService) {
		Try { 
                If ($global:bServicePaused -eq $false)  {
				#Place code for your service here
				#e.g. $ProcessList = Get-Process solitaire -ErrorAction SilentlyContinue
				
				# Use Write-Host or any other PowerShell output function to write to the System's application log
                If ($global:Service.ServiceDebug) {
                    $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
                }
                
                If ( $global:Service.Config.Invoke.ScriptArguments ) {
                    Invoke-Expression -Command "$($global:Service.Config.Invoke.ScriptPath) $($global:Service.Config.Invoke.ScriptArguments)" -ErrorAction Stop
                } Else {
                    Invoke-Expression -Command "$($global:Service.Config.Invoke.ScriptPath)" -ErrorAction Stop
                }
			} Else {
            
            }
		} Catch {
			# Log exception in application log
			Write-Host $_.Exception.Message
            If ($global:Service.ServiceDebug) {
                $_.Exception.Message | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
                $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
            }
		}
		
        #region Adjust sleep timing to determine how often your service becomes active.
    		If ($global:bServicePaused -eq $true) {
    			Start-Sleep -Seconds $global:Service.Config.Pause.LoopInterval # if the service is paused we sleep longer between checks.
    		} Else {
    			Start-Sleep –Seconds $global:Service.Config.Invoke.LoopInterval # a lower number will make your service active more often and use more CPU cycles
    		}
        #endregion Adjust sleep timing to determine how often your service becomes active.
	}
	$global:bServiceRunning	= $false
}

function Stop-MyService
{
	$global:bRunService = $false # Signal main loop to exit
	$CountDown = $global:StopLoopInterval # Maximum wait for loop to exit
	while($global:bServiceRunning -and $Countdown -gt 0)
	{
		Start-Sleep -Seconds 1 # wait for your main loop to exit
		$Countdown = $Countdown - 1
	}
	# Place code to be executed on service stop here
	# Close files and connections, terminate jobs and
	# use remove-module to unload blocking modules
    
    If ($global:Service.ServiceDebug) {
        $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
    }
    
    If ( $global:Service.Config.Stop.ScriptArguments ) {
        Invoke-Expression -Command "$($global:Service.Config.Stop.ScriptPath) $($global:Service.Config.Invoke.ScriptArguments)" -ErrorAction Stop
    } Else {
        Invoke-Expression -Command "$($global:Service.Config.Stop.ScriptPath)" -ErrorAction Stop
    }
}

function Pause-MyService
{
	# Service is being paused
	# Save state 
	$global:bServicePaused = $true
	# Note that the thread your PowerShell script is running on is not suspended on 'pause'.
	# It is your responsibility in the service loop to pause processing until a 'continue' command is issued.
	# It is recommended to sleep for longer periods between loop iterations when the service is paused.
	# in order to prevent excessive CPU usage by simply waiting and looping.
    
    If ($global:Service.ServiceDebug) {
        $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
    }
    
    If ( $global:Service.Config.Pause.ScriptArguments ) {
        Invoke-Expression -Command "$($global:Service.Config.Pause.ScriptPath) $($global:Service.Config.Invoke.ScriptArguments)" -ErrorAction Stop
    } Else {
        Invoke-Expression -Command "$($global:Service.Config.Pause.ScriptPath)" -ErrorAction Stop
    }
}

function Continue-MyService
{
	# Service is being continued from a paused state
	# Restore any saved states if needed
	$global:bServicePaused = $false
    
    If ($global:Service.ServiceDebug) {
        $($global:Service | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:Service.ServicePath) -Append
    }
    
    If ( $global:Service.Config.Continue.ScriptArguments ) {
        Invoke-Expression -Command "$($global:Service.Config.Continue.ScriptPath) $($global:Service.Config.Invoke.ScriptArguments)" -ErrorAction Stop
    } Else {
        Invoke-Expression -Command "$($global:Service.Config.Continue.ScriptPath)" -ErrorAction Stop
    }
}]]></Code>
</File>