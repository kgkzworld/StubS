<File version="3.2">
  <Code><![CDATA[# Warning: Do not rename Start-MyService, Invoke-MyService and Stop-MyService functions


function Start-MyService
{
	#region Initialize global variables
    	$global:bRunService = $true
    	$global:bServiceRunning = $false
    	$global:bServicePaused = $false
    #endregion Initialize global variables
    
    #region Grab File Information
        $global:CurFileInfo = Get-Process -Id $pid | Select-Object -ExpandProperty Path
        $global:ServiceHash = @{}
        $global:ServiceHash.ServicePath = $global:CurFileInfo | Split-Path -Parent
        $global:ServiceHash.ServiceConfigFile = $($global:CurFileInfo | Split-Path -Leaf) -replace '\.exe$','.json'
        $global:ServiceHash.ServiceDebug = $false
        
        If (Test-Path -Path $('{0}\{1}' -f $global:ServiceHash.ServicePath, $($global:CurFileInfo | Split-Path -Leaf) -replace '\.exe$','.debug')) {
            $global:ServiceHash.ServiceDebug = $true
            $($global:ServiceHash | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Force
        }
    #endregion Grab File Information
    
    #region Query Json Config
        Try {
            $global:ServiceHash.Config = Get-Content -Path $('{0}\{1}' -f $global:ServiceHash.ServicePath, $global:ServiceHash.ServiceConfigFile) -ErrorAction Stop
        } Catch {
            Write-Host $_.Exception.Message
            If ($global:ServiceHash.ServiceDebug) {
                $_.Exception.Message | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Append
                $($global:ServiceHash | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Append
            }
        }
    #endregion Query Json Config
        
    #region Update Execution Policy
        $global:CurPolicy = $(Get-ExecutionPolicy | Out-String).Trim()
        Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser
    #endregion Update Execution Policy
}

function Invoke-MyService
{
	$global:bServiceRunning = $true
	While ($global:bRunService) {
		Try { 
                If ($global:bServicePaused -eq $false)  {
				#Place code for your service here
				#e.g. $ProcessList = Get-Process solitaire -ErrorAction SilentlyContinue
				
				# Use Write-Host or any other PowerShell output function to write to the System's application log
                If ($global:ServiceHash.ServiceDebug) {
                    Write-Host 'Running in Invoke-MyService'
                    $($global:ServiceHash | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Append
                }
                
                If ( $global:ServiceHash.Config.Invoke.ScriptArguments ) {
                    Invoke-Expression -Command "$($global:ServiceHash.Config.Invoke.ScriptPath) $($global:ServiceHash.Config.Invoke.ScriptArguments)" -ErrorAction Stop
                } Else {
                    Invoke-Expression -Command "$($global:ServiceHash.Config.Invoke.ScriptPath)" -ErrorAction Stop
                }
			} Else {
            
            }
		} Catch {
			# Log exception in application log
			Write-Host $_.Exception.Message
            If ($global:ServiceHash.ServiceDebug) {
                $_.Exception.Message | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Append
                $($global:ServiceHash | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Append
            }
		}
		
        #region Adjust sleep timing to determine how often your service becomes active.
    		If ($global:bServicePaused -eq $true) {
    			Start-Sleep -Seconds $global:ServiceHash.Config.Pause.LoopInterval # if the service is paused we sleep longer between checks.
    		} Else {
    			Start-Sleep –Seconds $global:ServiceHash.Config.Invoke.LoopInterval # a lower number will make your service active more often and use more CPU cycles
    		}
        #endregion Adjust sleep timing to determine how often your service becomes active.
	}
	$global:bServiceRunning	= $false
}

function Stop-MyService
{
	$global:bRunService = $false # Signal main loop to exit
	$CountDown = $global:StopLoopInterval # Maximum wait for loop to exit
	while($global:bServiceRunning -and $Countdown -gt 0)
	{
		Start-Sleep -Seconds 1 # wait for your main loop to exit
		$Countdown = $Countdown - 1
	}
	# Place code to be executed on service stop here
	# Close files and connections, terminate jobs and
	# use remove-module to unload blocking modules
    
    If ($global:ServiceHash.ServiceDebug) {
        $($global:ServiceHash | ConvertTo-Json -Depth 5).ToString() | Out-File -FilePath $('{0}\Debugger.log' -f $global:ServiceHash.ServicePath) -Append
    }
    
    If ( $global:ServiceHash.Config.Stop.ScriptArguments ) {
        Invoke-Expression -Command "$($global:ServiceHash.Config.Stop.ScriptPath) $($global:ServiceHash.Config.Invoke.ScriptArguments)" -ErrorAction Stop
    } Else {
        Invoke-Expression -Command "$($global:ServiceHash.Config.Stop.ScriptPath)" -ErrorAction Stop
    }
}]]></Code>
</File>